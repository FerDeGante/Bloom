module.exports = {

"[project]/node_modules/@restart/hooks/esm/useMounted.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>useMounted)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/react [external] (react, cjs)");
;
function useMounted() {
    const mounted = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useRef"])(true);
    const isMounted = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useRef"])(()=>mounted.current);
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useEffect"])(()=>{
        mounted.current = true;
        return ()=>{
            mounted.current = false;
        };
    }, []);
    return isMounted.current;
}
}}),
"[project]/node_modules/@restart/hooks/esm/useUpdatedRef.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>useUpdatedRef)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/react [external] (react, cjs)");
;
function useUpdatedRef(value) {
    const valueRef = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useRef"])(value);
    valueRef.current = value;
    return valueRef;
}
}}),
"[project]/node_modules/@restart/hooks/esm/useWillUnmount.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>useWillUnmount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useUpdatedRef$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@restart/hooks/esm/useUpdatedRef.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/react [external] (react, cjs)");
;
;
function useWillUnmount(fn) {
    const onUnmount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useUpdatedRef$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"])(fn);
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useEffect"])(()=>()=>onUnmount.current(), []);
}
}}),
"[project]/node_modules/@restart/hooks/esm/useTimeout.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>useTimeout)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/react [external] (react, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useMounted$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@restart/hooks/esm/useMounted.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useWillUnmount$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@restart/hooks/esm/useWillUnmount.js [ssr] (ecmascript)");
;
;
;
/*
 * Browsers including Internet Explorer, Chrome, Safari, and Firefox store the
 * delay as a 32-bit signed integer internally. This causes an integer overflow
 * when using delays larger than 2,147,483,647 ms (about 24.8 days),
 * resulting in the timeout being executed immediately.
 *
 * via: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout
 */ const MAX_DELAY_MS = 2 ** 31 - 1;
function setChainedTimeout(handleRef, fn, timeoutAtMs) {
    const delayMs = timeoutAtMs - Date.now();
    handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(()=>setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);
}
function useTimeout() {
    const isMounted = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useMounted$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"])();
    // types are confused between node and web here IDK
    const handleRef = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$restart$2f$hooks$2f$esm$2f$useWillUnmount$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"])(()=>clearTimeout(handleRef.current));
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$react__$5b$external$5d$__$28$react$2c$__cjs$29$__["useMemo"])(()=>{
        const clear = ()=>clearTimeout(handleRef.current);
        function set(fn, delayMs = 0) {
            if (!isMounted()) return;
            clear();
            if (delayMs <= MAX_DELAY_MS) {
                // For simplicity, if the timeout is short, just set a normal timeout.
                handleRef.current = setTimeout(fn, delayMs);
            } else {
                setChainedTimeout(handleRef, fn, Date.now() + delayMs);
            }
        }
        return {
            set,
            clear,
            handleRef
        };
    }, []);
}
}}),
"[project]/node_modules/@restart/ui/cjs/useRootClose.js [ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
var _listen = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/dom-helpers/esm/listen.js [ssr] (ecmascript)"));
var _ownerDocument = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/dom-helpers/esm/ownerDocument.js [ssr] (ecmascript)"));
var _react = __turbopack_context__.r("[externals]/react [external] (react, cjs)");
var _useEventCallback = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/node_modules/@restart/hooks/cjs/useEventCallback.js [ssr] (ecmascript)"));
var _useClickOutside = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/useClickOutside.js [ssr] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/utils.js [ssr] (ecmascript)");
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
const noop = ()=>{};
/**
 * The `useRootClose` hook registers your callback on the document
 * when rendered. Powers the `<Overlay/>` component. This is used achieve modal
 * style behavior where your callback is triggered when the user tries to
 * interact with the rest of the document or hits the `esc` key.
 *
 * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
 * @param {function} onRootClose
 * @param {object=}  options
 * @param {boolean=} options.disabled
 * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
 */ function useRootClose(ref, onRootClose, { disabled, clickTrigger } = {}) {
    const onClose = onRootClose || noop;
    (0, _useClickOutside.default)(ref, onClose, {
        disabled,
        clickTrigger
    });
    const handleKeyUp = (0, _useEventCallback.default)((e)=>{
        if ((0, _utils.isEscKey)(e)) {
            onClose(e);
        }
    });
    (0, _react.useEffect)(()=>{
        if (disabled || ref == null) return undefined;
        const doc = (0, _ownerDocument.default)((0, _useClickOutside.getRefTarget)(ref));
        // Store the current event to avoid triggering handlers immediately
        // https://github.com/facebook/react/issues/20074
        let currentEvent = (doc.defaultView || window).event;
        const removeKeyupListener = (0, _listen.default)(doc, 'keyup', (e)=>{
            // skip if this event is the same as the one running when we added the handlers
            if (e === currentEvent) {
                currentEvent = undefined;
                return;
            }
            handleKeyUp(e);
        });
        return ()=>{
            removeKeyupListener();
        };
    }, [
        ref,
        disabled,
        handleKeyUp
    ]);
}
var _default = exports.default = useRootClose;
}}),
"[project]/node_modules/@restart/ui/cjs/Overlay.js [ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
var _react = _interopRequireWildcard(__turbopack_context__.r("[externals]/react [external] (react, cjs)"));
var React = _react;
var _reactDom = _interopRequireDefault(__turbopack_context__.r("[externals]/react-dom [external] (react-dom, cjs)"));
var _useCallbackRef = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/node_modules/@restart/hooks/cjs/useCallbackRef.js [ssr] (ecmascript)"));
var _useMergedRefs = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/node_modules/@restart/hooks/cjs/useMergedRefs.js [ssr] (ecmascript)"));
var _usePopper = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/usePopper.js [ssr] (ecmascript)"));
var _useRootClose = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/useRootClose.js [ssr] (ecmascript)"));
var _useWaitForDOMRef = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/useWaitForDOMRef.js [ssr] (ecmascript)"));
var _mergeOptionsWithPopperConfig = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/mergeOptionsWithPopperConfig.js [ssr] (ecmascript)"));
var _ImperativeTransition = __turbopack_context__.r("[project]/node_modules/@restart/ui/cjs/ImperativeTransition.js [ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Built on top of `Popper.js`, the overlay component is
 * great for custom tooltip overlays.
 */ const Overlay = /*#__PURE__*/ React.forwardRef((props, outerRef)=>{
    const { flip, offset, placement, containerPadding, popperConfig = {}, transition: Transition, runTransition } = props;
    const [rootElement, attachRef] = (0, _useCallbackRef.default)();
    const [arrowElement, attachArrowRef] = (0, _useCallbackRef.default)();
    const mergedRef = (0, _useMergedRefs.default)(attachRef, outerRef);
    const container = (0, _useWaitForDOMRef.default)(props.container);
    const target = (0, _useWaitForDOMRef.default)(props.target);
    const [exited, setExited] = (0, _react.useState)(!props.show);
    const popper = (0, _usePopper.default)(target, rootElement, (0, _mergeOptionsWithPopperConfig.default)({
        placement,
        enableEvents: !!props.show,
        containerPadding: containerPadding || 5,
        flip,
        offset,
        arrowElement,
        popperConfig
    }));
    // TODO: I think this needs to be in an effect
    if (props.show && exited) {
        setExited(false);
    }
    const handleHidden = (...args)=>{
        setExited(true);
        if (props.onExited) {
            props.onExited(...args);
        }
    };
    // Don't un-render the overlay while it's transitioning out.
    const mountOverlay = props.show || !exited;
    (0, _useRootClose.default)(rootElement, props.onHide, {
        disabled: !props.rootClose || props.rootCloseDisabled,
        clickTrigger: props.rootCloseEvent
    });
    if (!mountOverlay) {
        // Don't bother showing anything if we don't have to.
        return null;
    }
    const { onExit, onExiting, onEnter, onEntering, onEntered } = props;
    let child = props.children(Object.assign({}, popper.attributes.popper, {
        style: popper.styles.popper,
        ref: mergedRef
    }), {
        popper,
        placement,
        show: !!props.show,
        arrowProps: Object.assign({}, popper.attributes.arrow, {
            style: popper.styles.arrow,
            ref: attachArrowRef
        })
    });
    child = (0, _ImperativeTransition.renderTransition)(Transition, runTransition, {
        in: !!props.show,
        appear: true,
        mountOnEnter: true,
        unmountOnExit: true,
        children: child,
        onExit,
        onExiting,
        onExited: handleHidden,
        onEnter,
        onEntering,
        onEntered
    });
    return container ? /*#__PURE__*/ _reactDom.default.createPortal(child, container) : null;
});
Overlay.displayName = 'Overlay';
var _default = exports.default = Overlay;
}}),

};

//# sourceMappingURL=node_modules_%40restart_9cef117c._.js.map